<!DOCTYPE html> 

<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <meta property="og:image" content="http://rbuch703.de/osmsv/images/screenshot.png" />
    <meta property="og:description" content="See a 3D view of any position of the world directly from your web browser." />
    <meta property="og:title" content="Open Street View" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="http://rbuch703.de/osmsv/" />
    
    <meta property="fb:admins" content="100001025041261" />

    <link   type="text/css" rel="stylesheet" href="styles/global.css" media="screen" />
    <link   type="text/css" rel="stylesheet" href="styles/leaflet.css" />

    <style>
        @media (min-width: 1440px) {
              #leftNavDiv { float:left; margin-right:20px; width:400px}
              #contentDiv { margin-left: 420px; margin-right:10px; }
              #mapDiv { width:400px; height:300px }
          }

        @media (max-width: 1439px) {
              #leftNavDiv { margin-left: 10px; margin-right:50px; } /*leave a 50px bar on the right to */
              #contentDiv { margin-left: 10px; margin-right:50px; } /*allow for mouse and touch scrolling */
              #mapDiv { width:100%; height:600px }
          }

    </style>

    <script type="text/javascript" src="leaflet.js"></script>
    <script type="text/javascript" src="tile.js"></script>
    <script type="text/javascript" src="mapLayer.js"></script>
    <script type="text/javascript" src="buildings.js"></script>
    <script type="text/javascript" src="skydome.js"></script>
    <script type="text/javascript" src="apartment.js"></script>
    <script type="text/javascript" src="poly2tri.js"></script>

	<script type="text/javascript" src="gl-matrix.js" ></script>
	<script type="text/javascript" src="glu.js" ></script>
	<script type="text/javascript" src="math.js" ></script>

    <!-- <script src="webgl-debug.js"></script> -->
    
	<!--<script id="map-shader-fs" type="x-shader/x-fragment">
		precision mediump float;
        varying vec2 texCoordV;
        uniform sampler2D tex;
		void main(void) {
            gl_FragColor = texture2D(tex, texCoordV.st);
		}
	</script> -->

	<script id="texture-shader-fs" type="x-shader/x-fragment">
		precision mediump float;
        varying vec2 texCoordV;
        uniform sampler2D tex;
		void main(void) {
            gl_FragColor = texture2D(tex, texCoordV.st);
		}
	</script>

	<script id="building-shader-fs" type="x-shader/x-fragment">
		precision mediump float;
        varying vec3 texCoordV;
        varying vec3 normal;
        varying vec3 worldPosition;
        
        uniform sampler2D tex;
        //uniform float height;
		void main(void) {
		    const float c = 0.02;

            vec3 vView = normalize(- worldPosition); //direction vector from surface to camera (camera is always at (0,0,0) )
            float diffuse = abs( 0.5 * dot(vView, normal) );

            
            gl_FragColor = diffuse > 0.0 ? vec4( vec3(diffuse+0.3), 1.0): vec4(-diffuse+0.3, 0.0, 0.0, 1.0);
            
            if (texCoordV.z == 0.0) //HACK: z==0 --> building height was just guessed --> tint it red
                gl_FragColor = gl_FragColor * vec4(1.0, 0.9, 0.95, 1.0);

		}
	</script>
	
	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 vertexPosition;
        attribute vec2 vertexTexCoords;  			
		
		uniform mat4 modelViewProjectionMatrix;

        varying vec2 texCoordV;

		void main(void) {
			gl_Position = modelViewProjectionMatrix * vec4(vertexPosition, 1.0);
			texCoordV = vertexTexCoords;
		}
	</script>

	<script id="building-shader-vs" type="x-shader/x-vertex">
		attribute vec3 vertexPosition;
        attribute vec3 vertexTexCoords; 			
        attribute vec3 vertexNormal;
		
		uniform mat4 modelViewProjectionMatrix;

        varying vec3 texCoordV;
        varying vec3 normal;
        varying vec3 worldPosition;

		void main(void) {
			gl_Position = modelViewProjectionMatrix * vec4(vertexPosition, 1.0);
			worldPosition = vertexPosition; //pass through untransformed
			texCoordV = vertexTexCoords;
			normal = vertexNormal;
		}
	</script>

    <script id="edge-shader-vs" type="x-shader/x-vertex">
		attribute vec3 vertexPosition;
		
		uniform mat4 modelViewProjectionMatrix;

		void main(void) {
			gl_Position = modelViewProjectionMatrix * vec4(vertexPosition, 1.0);
		}
	</script>

	<script id="edge-shader-fs" type="x-shader/x-fragment">
		precision mediump float;

		void main(void) {
            gl_FragColor = vec4(0.2, 0.2, 0.2, 1.0);
		}
	</script>	
    
    <script type="text/javascript">
    "use strict"    
    function init()
    {
        map = L.map('mapDiv').setView([52.15, 11.63], 14); //global 

        map.on("click", onMapClick);
        map.on("zoomend", renderFrustum);

        /*L.tileLayer('http://ipsum4.rbuch703.de/osm/{z}/{x}/{y}.png', {
            attribution: 'OpenStreetMap',
            maxZoom: 19, minZoom:1
        }).addTo(map);*/
        L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'OpenStreetMap',
            maxZoom: 19, minZoom:1
        }).addTo(map);

        L.control.scale({imperial:false, position:"topright"}).addTo(map);
	    initGl();  //initialize webGL canvas

        if (gl)
        {
		    //register event handlers
		    webGlCanvas.onclick = scheduleFrameRendering;
		    webGlCanvas.onmousedown = onMouseDown;
		    webGlCanvas.onmouseup   = onMouseUp;
		    webGlCanvas.onmouseout  = onMouseUp;
		    webGlCanvas.onmousemove = onMouseMove;
            webGlCanvas.addEventListener("touchstart",  onTouchDown,false);
            webGlCanvas.addEventListener("touchcancel", onTouchEnd, false);
            webGlCanvas.addEventListener("touchend",    onTouchEnd, false);
            webGlCanvas.addEventListener("touchleave",  onTouchEnd, false);
            webGlCanvas.addEventListener("touchmove",   onTouchMove,false);
        }

		document.body.onresize = onResize;
		sampleLocations.onchange = onSampleLocationSelected;

        var url = document.URL;
        if (url.indexOf("?") >= 0)
        {
            var query = url.substring(url.indexOf("?")+1);
        }
        else
            //default to a view of the Berlin Bundestag
            var query = "lat=52.5184&lng=13.3725&yaw=104&pitch=10";
            
        var parts = query.split("&");
        var res = {};
        for (var i in parts)
        {
            var part = parts[i];
            var kv = part.split("=");
            if (kv.length == 2)
            {
                res[kv[0]] = parseFloat(kv[1]);
            }
        }
        
        if (res.lat && res.lng)
        {
            var e = {};
            e.latlng = {lat:res.lat, lng:res.lng};
            
            if ( ("yaw" in  res) && ("pitch" in res) ) //if look direction is also given
            {
                viewAngleYaw = res.yaw;
                viewAnglePitch=res.pitch;
            }
            
            //map.panTo(L.latLng(res.lat, res.lng));
            onMapClick(e);
        }

        /* For the narrow layout, the 3D view should come directly after the map to reduce the need for scrolling and to
         * improve chances that map and 3D view will fit on the same page.
         * For the wide layout, the social media div (Facebook integration) should be in the left navigation column, 
         * logically in between the map and the 3D view.
         */
        narrowLayout = window.matchMedia( "(max-width: 1439px)" );
        narrowLayout.addListener(function() {(narrowLayout.matches ? contentDiv : leftNavDiv).appendChild(socialMediaDiv);});
        (narrowLayout.matches ? contentDiv : leftNavDiv).appendChild(socialMediaDiv); //to handle the initial layout
    }   
    
    var narrowLayout;
    var map;
    var mapPlane;
    var mapBuildings;
    var mapSkyDome;
    var mapApartment;
    var mapFrustum;
    var gl;
    var eye,position;
    var localPosition = { x:0, y:0 }; //camera position in the local coordinate system
    var viewAngleYaw = 0;
    var viewAnglePitch = 0;
    var positionMarker;
    var fieldOfView = 45;
    
    function updateHistoryState()
    {
        var url = document.URL;
        if (url.indexOf("?") >= 0) // already contains a query string
            url = url.substring(0, url.indexOf("?"));
        
        url += "?lat="+position.lat+"&lng="+position.lng+"&yaw="+viewAngleYaw.toFixed(1)+"&pitch="+viewAnglePitch.toFixed(1);
        history.replaceState(null, document.title, url);
    }
    
    var updateTimeoutId;
    // schedules a history state update so that the update is performed once
    // no update request has been made for a second (1000ms). This keep the history state
    // reasonably up-to-date while preventing excessive history state updates (which incur
    // a performance penalty at least in Firefox).
    function scheduleUpdateHistoryState()
    {
        if (updateTimeoutId)
            window.clearTimeout(updateTimeoutId);
        
        updateTimeoutId = window.setTimeout(updateHistoryState, 1000);
    }
    
    function onMapClick(e)
    {
        position = e.latlng;
        map.panTo(e.latlng);
        if (map.getZoom() < 16)
            map.setZoom(16);
        
        mapPlane = new MapLayer(gl, position);
        mapPlane.onProgress= scheduleFrameRendering;
        
        mapBuildings = new Buildings(gl, position);
        mapBuildings.onLoaded = scheduleFrameRendering;
        
        mapApartment = new Apartment(10/720.0, 21);
        
        if (positionMarker)
            map.removeLayer(positionMarker);
        
        positionMarker = L.marker([position.lat, position.lng])
        
        positionMarker.addTo(map).bindPopup("You are here");
        //console.log("Setting map center to %o", position);
        scheduleUpdateHistoryState();
        renderFrustum();
        /* make sure the 3D view is visible when a user clicked on the map (as this is usually what the user wants
         * when he clicks on a map location. For the wide layout, the 3D view should align with the top of the screen ("true")
         * to show the whole 3D view. For the narrow layout, the 3D view is the last important part on the page and should
         * align with the bottom of the page to allow the map to be shown above. */
        
        webGlCanvas.scrollIntoView( narrowLayout ? !narrowLayout.matches : true);
    }   
    
    function onSampleLocationSelected(e)
    {
        if (sampleLocations.value !== "dummy")
        {
            var pos = JSON.parse(sampleLocations.value);

            if ("yaw" in pos)
                viewAngleYaw = pos.yaw;
            if ("pitch" in pos)
                viewAnglePitch = pos.pitch;
                
            if ("lat" in pos && "lng" in pos)
                onMapClick( {"latlng":pos});
            //window.location.href = sampleLocations.value;
        }
    }

	var x,y;
	//id of the touch event that is currently tracked as 'down'; "mouse" if the mouse is tracked, null if none
    var down = null;	
    		
	function onMouseDown(e)
	{
	    if (e.button != 0) 
	        return;

	    x = e.clientX;
	    y = e.clientY;
	    down = "mouse";
	}
	
	function onMouseUp(e)
	{
	    if (e.button != 0) 
	        return;
	    down = null;
	}
	
	var keysDown = {};
	
	var lastKeyEventProcessed = null;

	function updateKeyInteraction()
	{
        var now = new Date().getTime();

        if (lastKeyEventProcessed === null)
        {
            lastKeyEventProcessed = now;
            return;
        }

        
        var dt = now - lastKeyEventProcessed;
        lastKeyEventProcessed = now;
        
        var arc = viewAngleYaw / 180 * Math.PI;
        var forwardX = Math.sin(arc);
        var forwardY = Math.cos(arc);

        var rightX = Math.sin(arc + Math.PI/2.0);
        var rightY = Math.cos(arc + Math.PI/2.0);
        
        if (keysDown.D) { localPosition.x += rightX * dt/400; localPosition.y += rightY * dt/400;};
        if (keysDown.A) { localPosition.x -= rightX * dt/400; localPosition.y -= rightY * dt/400;};

        if (keysDown.W) { localPosition.x += forwardX * dt/400; localPosition.y +=forwardY * dt/400;}
        if (keysDown.S) { localPosition.x -= forwardX * dt/400; localPosition.y -=forwardY * dt/400;}

	        
	}
	
	document.onkeydown = function(evt) 
	{
        //console.log("Key event: key %s", evt.keyCode);
        var key = null;
        switch (evt.keyCode)
        {
            
            case 65: key = "A"; break;
            case 68: key = "D"; break;
            case 83: key = "S"; break;
            case 87: key = "W"; break;
        }
        
        if (key in keysDown) //is just a reoccuring event for a key that is still pressed
            return;
            
        updateKeyInteraction();
        keysDown[key] = key;
        
        scheduleFrameRendering();
    };

	document.onkeyup = function(evt) 
	{
        //console.log("Key event: key %s", evt.keyCode);
        switch (evt.keyCode)
        {
            
            case 65: delete keysDown.A; break;
            case 68: delete keysDown.D; break;
            case 83: delete keysDown.S; break;
            case 87: delete keysDown.W; break;
        }
    }
	
	function updateViewDirection(dx, dy)
	{
        viewAngleYaw += dx/5 ;
        viewAnglePitch += dy/ 5;
        if (viewAnglePitch > 180)
            viewAnglePitch -= 180;
        
        if (viewAnglePitch < -60)
            viewAnglePitch = -60;
            
        if (viewAnglePitch > 60)
            viewAnglePitch = 60;
        /*localPosition.x += dx/100;
        localPosition.y += dy/100;*/

        scheduleUpdateHistoryState();
        scheduleFrameRendering();
	}
	
    function onMouseMove(e)
	{
        if (down != "mouse" ) return;
        var dx = e.clientX - x;
        var dy = e.clientY - y;

        //if (Math.abs(dx) + Math.abs(dy) < 5)
        //    return;
        x = e.clientX;
        y = e.clientY;

        updateViewDirection(dx, dy);
	}	

    function getTouchData(touches, identifier)
    {
        for (var i in touches)
        {
            if (touches[i].identifier == identifier)
            {
                return touches[i];
            }
        }
        return null;
    }
    
    function onTouchDown(ev)
    {
        ev.preventDefault();
        var touch = ev.changedTouches[0];
        down = touch.identifier;
        x = touch.clientX;
        y = touch.clientY;
    }
    
    function onTouchEnd(ev)
    {
    
        ev.preventDefault();
        if (getTouchData(ev.changedTouches, down))
        {
            down = null;
        }
    }

    function onTouchMove(ev)
    {
    
        ev.preventDefault();
        var touch = getTouchData(ev.changedTouches, down);
        if (touch)
        {
            var dx = touch.clientX - x;
            var dy = touch.clientY - y;

            if (Math.abs(dx) < 5 && Math.abs(dy) < 5)
                return;
            x = touch.clientX;
            y = touch.clientY;
            updateViewDirection(dx, dy);
            
        }
    }
    
    
    var frameRenderingScheduled = false;
    function scheduleFrameRendering()
    {
        if (frameRenderingScheduled)
            return;

        frameRenderingScheduled = true;
        if (window.requestAnimationFrame)
            window.requestAnimationFrame(executeFrameRendering);
        else
            executeFrameRendering();
    }
    
    function executeFrameRendering(dummy)
    {
        updateKeyInteraction();

        renderFrustum();
        renderScene();
        frameRenderingScheduled = false;
        
        // If at least one key is still pressed, schedule rendering of the next frame right away:
        // A pressed key will potentially change the scene and require a re-rendering
        if (Object.keys(keysDown).length)   
            scheduleFrameRendering();
    }

	
	function renderFrustum()
	{
	    if (!gl)
	        return;
	    if (mapFrustum)
	    {
	        map.removeLayer(mapFrustum);
	        mapFrustum = null;
        }
	    
	    /* One degree latitude on earth always corresponds to the same distance in meters ( 1/360th of the earth circumference).
	     * But the distance of one degree longitude changes depending of the current latitude.
	     * This aspect is the ration between the two distances. It is needed to correctly
	     * draw that viewing frustum, which needs to be specified in lat/lnt
	    */
	    var localAspect = Math.cos( position.lat / 180 * Math.PI);
	    
        var yawRad = viewAngleYaw / 180 * Math.PI;
        /* compute only planar lookDir (ignoring pitch), as this is the relevant direction to render the frustum
           on a 2D map
         */
        var lookDir = [Math.sin( yawRad), Math.cos(yawRad)];
	    
	    //console.log ("local aspect ratio at %s is %s", position.lat, localAspect );
	    
	    //console.log( webGlCanvas.height, webGlCanvas.width, fieldOfView / webGlCanvas.height * webGlCanvas.width);
	    var phi = (0.5 * fieldOfView / webGlCanvas.height * webGlCanvas.width ) / 180 * Math.PI;
	    var leftDir = [ Math.cos(phi) * lookDir[0]  - Math.sin(phi) * lookDir[1], 
	                    Math.sin(phi) * lookDir[0]  + Math.cos(phi) * lookDir[1] ];
	    var rightDir =[ Math.cos(-phi) * lookDir[0] - Math.sin(-phi) * lookDir[1], 
	                    Math.sin(-phi) * lookDir[0] + Math.cos(-phi) * lookDir[1] ];

        var len = Math.pow(0.5, map.getZoom())*2000;
        //console.log(map.getZoom(), len);
	    var pA = { lat: position.lat + leftDir[1]*len*localAspect,  lng: position.lng + leftDir[0]*len };
	    var pB = { lat: position.lat + rightDir[1]*len*localAspect, lng: position.lng + rightDir[0]*len};
	    var line = [position, pA, pB, position ]
	    mapFrustum = L.polygon(line, {color: 'red', noClip: 'true', fillColor:"white", fillOpacity:0.4}).addTo(map);
	}
	
	/**
	 * Initialises WebGL and creates the 3D scene.
	 */
	function initGl()
	{
        //create context
		gl = webGlCanvas.getContext("webgl") || webGlCanvas.getContext("experimental-webgl");
		if(!gl)
		{
		    //remove controls that depend on webGL, and show error messages
	        glErrorDiv.style.display = "inherit";
	        leftNavDiv.style.display = "none";
	        gl = null;
	        contentDiv.removeChild(webGlCanvas);
			return;
		}
		//gl = WebGLDebugUtils.makeDebugContext(gl);
		
		gl.clearColor(0.5, 0.5, 0.5, 1.0);

		gl.clearDepth(1.0);
		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);
		

        gl.enable(gl.CULL_FACE);

        onResize();
	
        //view setup 
        eye = [0,0,1.5+21];

        mapSkyDome = new SkyDome(gl);
        mapSkyDome.onLoaded = scheduleFrameRendering;

	}
	

	function onResize()
	{
        webGlCanvas.height = webGlCanvas.clientHeight;
        webGlCanvas.width  = webGlCanvas.clientWidth;
	    
	    if (gl)
	    {
			gl.viewport(0, 0, webGlCanvas.width, webGlCanvas.height);
			scheduleFrameRendering();
		}
	}	
	
	function renderScene()
	{
	    if (!gl || !eye ) //not yet initialized
	        return;
	        
	        
        var yawRad = viewAngleYaw / 180 * Math.PI;
        var pitchRad=viewAnglePitch / 180 * Math.PI;
        var lookDir = [Math.sin( yawRad) * Math.cos(pitchRad), Math.cos(yawRad) * Math.cos( pitchRad ),  Math.sin( pitchRad)];
	    //console.log("?lat="+position.lat+"&lng="+position.lng+"&lookx="+lookDir[0]+"&looky="+lookDir[1]);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        //determine look-at point
	    var lookAt = vec3.create();
        vec3.add(lookAt, eye, lookDir);
	
		var modelViewMatrix = mat4.create();
		mat4.lookAt(modelViewMatrix, eye,  lookAt,[0, 0, 1]);
		mat4.translate(modelViewMatrix, modelViewMatrix, [-localPosition.x, -localPosition.y, 0]);
		mat4.scale(modelViewMatrix, modelViewMatrix, [1,-1,1]);//negate y coordinate to make positive y go downward

	    var projectionMatrix = mat4.create();
	    mat4.perspective(projectionMatrix, fieldOfView/180*Math.PI, webGlCanvas.width / webGlCanvas.height, 0.1, 10000.0);


        var renderItems = [mapPlane, mapBuildings, mapSkyDome, mapApartment];
        for (var i in renderItems)
            if (renderItems[i])
                renderItems[i].render(modelViewMatrix, projectionMatrix);

		gl.flush();
	}
	
    </script>
    <title>Open Street View</title>
</head>

<body onload="init()"  > <!-- style ="padding: 0px; margin: 0px;" -->

<!-- initialization for Facebook integration --> 
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.0";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<div id="glErrorDiv" style="display:none">
    <h2 style="">Open Street View</h2>

    <p style="font-weight:bold; color:#F00">
    Unfortunately, your browser does not support 3D web graphics ("WebGL"), which are required for this page to work.</p>
    <p>
    This page should work on desktop and laptop computers with most recent browsers (e.g. Firefox, Chrome, Internet Explorer). To date, desktop Safari browsers require <a target="_blank" href="https://discussions.apple.com/thread/3300585?start=0">some tuning</a> to support 3D web graphics.</p>
    <p>
    For mobile devices (tablets and smartphones), most recent Android-based devices (usually those with Android 4.3 and newer) should support 3D web graphics. Apple's iPhone and iPad series of devices currently does not.
    </p>
    Here's a screenshot of what you are missing:<br>
    <img src="images/screenshot.png">
</div>


<div id="leftNavDiv" style="">
    <h2 style="">Open Street View</h2>

    <div id="explanation"> 
        <p>Click on any location on the map to see a 3D view of the world as seen from that position. Then click and drag the 3D view with your mouse to look around.</p>
        <p>Here are some location suggestions: 
            <select id="sampleLocations">
              <option value="dummy">-- select one --</option>
              <option value='{"lat":51.4979,  "lng":-0.1203,   "yaw":303, "pitch":7 }'>London (House of Parliament)</option>
              <option value='{"lat":40.7683,  "lng":-73.9794,  "yaw":261, "pitch":14}'>New York City (Central Park)</option>
              <option value='{"lat":38.9001,  "lng":-77.0364,  "yaw":187, "pitch":0 }'>Washington DC(The White House)</option>
              <option value='{"lat":36.1132,  "lng":-115.1727, "yaw":284, "pitch":12}'>Las Vegas (The Bellagio)</option>
              <option value='{"lat":52.509344,"lng":13.375242, "yaw":299, "pitch":15}'>Berlin (Potsdamer Platz)</option>
              <option value='{"lat":52.5184,  "lng":13.3725,   "yaw":104, "pitch":10}'>Berlin (Bundestag, Brandenburger Tor)</option>
              <option value='{"lat":51.3429,  "lng":12.3820,   "yaw":343, "pitch":11}'>Leipzig (Main Station)</option>
              <option value='{"lat":52.1394,  "lng":11.6396,   "yaw":203, "pitch":17}'>Magdeburg (Universit√§tsplatz)</option>
            </select> 
        </p>
        <p>Buildings missing or inaccurate? <a href="howToEdit.html" target="_blank">Add them yourself</a>!</p>
    </div>

    <div id="mapDiv" style="margin-bottom:15px"> </div>
    
    <div id="socialMediaDiv" >
    <p>
    Let me know what you think about this page:</p>
    <!-- Facebook like/share box box -->
        <div class="fb-like" data-href="http://rbuch703.de/osmsv" data-layout="button_count" data-action="like" data-show-faces="false" data-share="true"></div>

    <!-- Facebook comment box -->
        <div class="fb-comments" data-href="http://rbuch703.de/osmsv" data-width="400px" data-numposts="5" data-colorscheme="light"></div>

    </div>

</div>


<div id="contentDiv" >
    <!-- <div id="nav" style="background-color:#EEE; position:fixed; width:75%; top:50px; bottom:0px; right: 0px; overflow-y:scroll">-->
		<canvas id="webGlCanvas" style="width:100%; height:auto;background:black" ></canvas>
        <div style="font-size:80%; font-style:italic">
The map and building geometry are &copy;OpenStreetMap contributors and are <a href="http://www.openstreetmap.org/copyright">licensed</a> under the Creative Commons BY-SA (map) and Open Database License (buildings) licenses.<br> For administrative questions on this page please contact the <a href="mailto:rbuch703@gmail.com">webmaster</a>.
        </div>

    </div>
</div> 


</body>


</html>
